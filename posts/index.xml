<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on dotNetting</title><link>https://dotnetting.net/posts/</link><description>Recent content in Posts on dotNetting</description><generator>Hugo</generator><language>en-gb</language><lastBuildDate>Wed, 08 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://dotnetting.net/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>How to use task-coalescing in C# to stop doing wasteful work</title><link>https://dotnetting.net/2025/01/how-to-use-task-coalescing-in-c%23-to-stop-doing-wasteful-work/</link><pubDate>Wed, 08 Jan 2025 00:00:00 +0000</pubDate><guid>https://dotnetting.net/2025/01/how-to-use-task-coalescing-in-c%23-to-stop-doing-wasteful-work/</guid><description>The post discusses a common inefficiency in multithreaded applications where multiple tasks redundantly compute the same result, particularly in scenarios involving high-concurrency requests to remote servers. It introduces the task-coalescing technique, which ensures that only one task fetches the data while others reuse the result, reducing wasteful work. Using .NET&amp;rsquo;s &lt;code>Lazy&amp;lt;T&amp;gt;&lt;/code> and &lt;code>ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code>, the example implementation demonstrates how to achieve this efficiently, mitigating issues like &lt;strong>cache stampedes&lt;/strong> and improving performance with minimal code changes.</description></item><item><title>How to do logging in .NET AWS Lambda functions</title><link>https://dotnetting.net/2023/05/how-to-do-logging-in-.net-aws-lambda-functions/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>https://dotnetting.net/2023/05/how-to-do-logging-in-.net-aws-lambda-functions/</guid><description>The article outlines four ways to send logs to AWS Cloudwatch from a .NET Lambda function. It covers &lt;code>ILambdaContext.Logger&lt;/code>, a basic option for simple logging; &lt;code>LambdaILogger&lt;/code>, which integrates with Microsoft&amp;rsquo;s &lt;code>ILogger&lt;/code> for richer features but has limitations with parameter serialization; &lt;code>Serilog&lt;/code>, a highly customizable library for structured logging and control over log formats; and &lt;code>AWS Lambda Powertools&lt;/code>, a straightforward utility tailored for &lt;strong>AWS Lambda&lt;/strong> with built-in X-Ray trace correlation. The choice between these methods depends on the need for simplicity or advanced customization.</description></item><item><title>How to use Visual Studio without Docker Desktop to debug a .NET Core application running in a container inside WSL</title><link>https://dotnetting.net/2022/01/how-to-use-visual-studio-without-docker-desktop-to-debug-a-.net-core-application-running-in-a-container-inside-wsl/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>https://dotnetting.net/2022/01/how-to-use-visual-studio-without-docker-desktop-to-debug-a-.net-core-application-running-in-a-container-inside-wsl/</guid><description>This post provides a step-by-step guide to setting up a development environment that allows debugging .NET Core applications inside a Docker container running on &lt;strong>WSL&lt;/strong>, using Visual Studio, without relying on &lt;strong>Docker Desktop&lt;/strong>. It outlines the prerequisites, the process of installing and configuring Docker tools on WSL2, enabling SSH for remote debugging, and attaching Visual Studio to the running container for debugging. While this approach requires manual setup, it offers a cost-effective alternative to Docker Desktop for teams who prefer or need to avoid its licensing fees.</description></item><item><title>Testing: Simulate database failures using EF Core Interceptors</title><link>https://dotnetting.net/2021/05/testing-simulate-database-failures-using-ef-core-interceptors/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://dotnetting.net/2021/05/testing-simulate-database-failures-using-ef-core-interceptors/</guid><description>The post explains how to use &lt;strong>EF Core Interceptors&lt;/strong> to simulate database failures, enabling tests for application resiliency. It introduces a custom &lt;code>MockFailCommandInterceptor&lt;/code> that selectively throws exceptions during specific database operations, such as &lt;code>INSERT&lt;/code>, to test failure scenarios. This approach ensures that failure handling is thoroughly tested.</description></item><item><title>How to route requests based on HTTP headers in ASP.NET Core</title><link>https://dotnetting.net/2021/04/how-to-route-requests-based-on-http-headers-in-asp.net-core/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><guid>https://dotnetting.net/2021/04/how-to-route-requests-based-on-http-headers-in-asp.net-core/</guid><description>The blog post addresses how to route API requests that use the same HTTP verb and path but differ in behavior based on HTTP header values, such as the &lt;code>Accept&lt;/code> header for versioning. It introduces a custom &lt;code>Accepts&lt;/code> attribute in &lt;strong>ASP.NET Core&lt;/strong>, which implements the &lt;code>IActionConstraint&lt;/code> interface to direct requests to specific actions based on header values. This approach can be extended to handle any scenario where routing depends on header values, beyond versioning.</description></item></channel></rss>