<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Task on dotNetting</title><link>https://dotnetting.net/tags/task/</link><description>Recent content in Task on dotNetting</description><generator>Hugo</generator><language>en-gb</language><lastBuildDate>Wed, 08 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://dotnetting.net/tags/task/index.xml" rel="self" type="application/rss+xml"/><item><title>How to use task-coalescing in C# to stop doing wasteful work</title><link>https://dotnetting.net/2025/01/how-to-use-task-coalescing-in-c%23-to-stop-doing-wasteful-work/</link><pubDate>Wed, 08 Jan 2025 00:00:00 +0000</pubDate><guid>https://dotnetting.net/2025/01/how-to-use-task-coalescing-in-c%23-to-stop-doing-wasteful-work/</guid><description>The post discusses a common inefficiency in multithreaded applications where multiple tasks redundantly compute the same result, particularly in scenarios involving high-concurrency requests to remote servers. It introduces the task-coalescing technique, which ensures that only one task fetches the data while others reuse the result, reducing wasteful work. Using .NET&amp;rsquo;s &lt;code>Lazy&amp;lt;T&amp;gt;&lt;/code> and &lt;code>ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code>, the example implementation demonstrates how to achieve this efficiently, mitigating issues like &lt;strong>cache stampedes&lt;/strong> and improving performance with minimal code changes.</description></item></channel></rss>