<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How to use task-coalescing in C# to stop doing wasteful work - dotNetting</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="This post shows how to apply a technique known as task-coalescing to mitigate issues from cache stampede and stop doing wasteful work in multithreaded applications."><meta property="og:url" content="https://dotnetting.net/2025/01/how-to-use-task-coalescing-in-c%23-to-stop-doing-wasteful-work/"><meta property="og:site_name" content="dotNetting"><meta property="og:title" content="How to use task-coalescing in C# to stop doing wasteful work"><meta property="og:description" content="This post shows how to apply a technique known as task-coalescing to mitigate issues from cache stampede and stop doing wasteful work in multithreaded applications."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-08T00:00:00+00:00"><meta property="article:tag" content="Dotnet"><meta property="article:tag" content="Csharp"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Task-Coalescing"><meta property="article:tag" content="Task"><meta property="article:tag" content="Cache-Stampede"><meta itemprop=name content="How to use task-coalescing in C# to stop doing wasteful work"><meta itemprop=description content="This post shows how to apply a technique known as task-coalescing to mitigate issues from cache stampede and stop doing wasteful work in multithreaded applications."><meta itemprop=datePublished content="2025-01-08T00:00:00+00:00"><meta itemprop=dateModified content="2025-01-08T00:00:00+00:00"><meta itemprop=wordCount content="1028"><meta itemprop=keywords content="Dotnet,Csharp,Concurrency,Task-Coalescing,Task,Cache-Stampede,Lazy,Concurrentdictionary"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to use task-coalescing in C# to stop doing wasteful work"><meta name=twitter:description content="This post shows how to apply a technique known as task-coalescing to mitigate issues from cache stampede and stop doing wasteful work in multithreaded applications."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-VGT0SY9PT3"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VGT0SY9PT3")}</script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=dotNetting rel=home><div class="logo__item logo__text"><div class=logo__title>dotNetting</div><div class=logo__tagline>netting the cloud with C# and AI</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>How to use task-coalescing in C# to stop doing wasteful work</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 16 16"><path d="M8 1c2 0 3.5 2 3.5 4.5S10 9 10 9c3 1 4 2 4 6H2c0-4 1-5 4-6 0 0-1.5-1-1.5-3.5S6 1 8 1"/></svg><span class=meta__text>Lester Sanchez</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2025-01-08T00:00:00Z>2025-01-08</time></div></div></header><div class="content post__content clearfix"><h2 id=problem>Problem</h2><p>In a multithreaded application, when multiple tasks run concurrently, it is in most cases wasteful and inefficient for every task to compute the same result. A more efficient approach is for only one of those tasks, generally the first to start running, to do the work and produce the result. The other tasks can <em>sit</em> and wait for the first one to complete and then share and reuse the same result.</p><p>Imagine an application that receives a high number of requests that require some data from a remote server. The remote server can be a REST API, a database or something else. In some cases we control both, the application and the remote server, and we have some flexibility to scale up and down both, to accommodate the traffic. In some other cases, we cannot control how the remote server scales, and have to adhere to their rate limiting policies. No matter what the case is, as a good practice we should always avoid doing wasteful work.</p><p>A common <em>solution</em> for this kind of problem is throwing a cache to store and reuse the results from the remote server for a while, before going and fetching them again. The use of cache, although correct in some of these cases, comes with its own challenges, out of the scope of this discussion&mldr; mostly. There is one particular challenge that task-coalescing helps to mitigate: the <a href=https://en.wikipedia.org/wiki/Cache_stampede>cache stampede</a>.</p><p>Task-coalescing technique can be used to protect downstream services (including cache) and databases from sudden spikes that involve fetching the same data concurrently.</p><p>Let&rsquo;s examine the following code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// The content of this record is not relevant, it is intentionally oversimplified</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>WeatherForecast</span>(<span style=color:#66d9ef>string</span> Location, <span style=color:#66d9ef>int</span> Temperature) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WeatherForecastService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, WeatherForecast&gt; _forecast = <span style=color:#66d9ef>new</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [&#34;London&#34;]</span> = <span style=color:#66d9ef>new</span> WeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>, Temperature: Random.Shared.Next(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>)),
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [&#34;Sydney&#34;]</span> = <span style=color:#66d9ef>new</span> WeatherForecast(<span style=color:#e6db74>&#34;Sydney&#34;</span>, Temperature: Random.Shared.Next(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>)),
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [&#34;Havana&#34;]</span> = <span style=color:#66d9ef>new</span> WeatherForecast(<span style=color:#e6db74>&#34;Havana&#34;</span>, Temperature: Random.Shared.Next(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>))
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;WeatherForecast&gt; GetWeatherForecast(<span style=color:#66d9ef>string</span> location)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Fetching Weather Forecast for {0}...&#34;</span>, location);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Simulate latency to retrieve remote data</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This will be normally a HTTP Request to the WeatherForecast API</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Task.Delay(<span style=color:#ae81ff>1000</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _forecast[location];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> service = <span style=color:#66d9ef>new</span> WeatherForecastService();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Assume these are concurrent requests from users</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> requests = <span style=color:#66d9ef>new</span> List&lt;Task&lt;WeatherForecast&gt;&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    service.GetWeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>),
</span></span><span style=display:flex><span>    service.GetWeatherForecast(<span style=color:#e6db74>&#34;Sydney&#34;</span>),
</span></span><span style=display:flex><span>    service.GetWeatherForecast(<span style=color:#e6db74>&#34;Havana&#34;</span>),
</span></span><span style=display:flex><span>    service.GetWeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>),
</span></span><span style=display:flex><span>    service.GetWeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>),
</span></span><span style=display:flex><span>    service.GetWeatherForecast(<span style=color:#e6db74>&#34;Havana&#34;</span>),
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> forecast = <span style=color:#66d9ef>await</span> Task.WhenAll(requests);
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> f <span style=color:#66d9ef>in</span> forecast)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(f);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The previous is a fairly standard implementation. If we run that code, we get the following output, showing that every task is going and fetching the same weather forecast data from the downstream service. A wasteful effort.</p><pre tabindex=0><code>Fetching Weather Forecast for London...
Fetching Weather Forecast for Sydney...
Fetching Weather Forecast for Havana...
Fetching Weather Forecast for London...
Fetching Weather Forecast for London...
Fetching Weather Forecast for Havana...

WeatherForecast { Location = London, Temperature = 31 }
WeatherForecast { Location = Sydney, Temperature = 12 }
WeatherForecast { Location = Havana, Temperature = 15 }
WeatherForecast { Location = London, Temperature = 31 }
WeatherForecast { Location = London, Temperature = 31 }
WeatherForecast { Location = Havana, Temperature = 15 }
</code></pre><p>A better outcome would it be for only one of these requests per location, to go a fetch the forecast from the downstream service. For the other requests, they should wait and reuse the retrieved forecast.</p><h2 id=solution>Solution</h2><p>I&rsquo;m going to implement a technique known as task-coalescing to achieve the better outcome described before. Instead of doing this from scratch, I will leverage two existing types in .NET to help me deal with the concurrent nature of this problem: <a href=https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1><code>Lazy&lt;T></code></a> and <a href=https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2><code>ConcurrentDictionary&lt;TKey, TValue></code></a>.</p><p>I will use <code>Lazy&lt;T></code> to wrap the request tasks in my previous example. <code>Lazy&lt;T></code> implementation will ensure that only the first thread to start executing the <code>Task</code> factory will run. Any other threads will be blocked and wait for that result. To complement my implementation, I will use the thread-safe <code>ConcurrentDictionary</code> to temporarily store the <code>Lazy&lt;Task&lt;T>></code> instances, until the tasks complete. This allows for any concurrent threads asking for the same value to <em>join</em> the leading task and wait for the result. Let&rsquo;s see the code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CoalescedWeatherForecastService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, WeatherForecast&gt; _forecast = <span style=color:#66d9ef>new</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [&#34;London&#34;]</span> = <span style=color:#66d9ef>new</span> WeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>, Temperature: Random.Shared.Next(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>)),
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [&#34;Sydney&#34;]</span> = <span style=color:#66d9ef>new</span> WeatherForecast(<span style=color:#e6db74>&#34;Sydney&#34;</span>, Temperature: Random.Shared.Next(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>)),
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [&#34;Havana&#34;]</span> = <span style=color:#66d9ef>new</span> WeatherForecast(<span style=color:#e6db74>&#34;Havana&#34;</span>, Temperature: Random.Shared.Next(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>))
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ConcurrentDictionary&lt;<span style=color:#66d9ef>string</span>, Lazy&lt;Task&lt;WeatherForecast&gt;&gt;&gt; _cachedLazyTasks = <span style=color:#66d9ef>new</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Task&lt;WeatherForecast&gt; GetWeatherForecast(<span style=color:#66d9ef>string</span> location)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _cachedLazyTasks.GetOrAdd(location, <span style=color:#66d9ef>new</span> Lazy&lt;Task&lt;WeatherForecast&gt;&gt;(() =&gt; Task.Run(<span style=color:#66d9ef>async</span> () =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Fetching Weather Forecast for {0}...&#34;</span>, location);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Simulate latency to retrieve remote data</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// This will be normally a HTTP Request to the WeatherForecast API</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>await</span> Task.Delay(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> _forecast[location];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                _cachedLazyTasks.TryRemove(location, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>var</span> _);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }))).Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> coalescedService = <span style=color:#66d9ef>new</span> CoalescedWeatherForecastService();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> coalescedRequests = <span style=color:#66d9ef>new</span> List&lt;Task&lt;WeatherForecast&gt;&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    coalescedService.GetWeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>),
</span></span><span style=display:flex><span>    coalescedService.GetWeatherForecast(<span style=color:#e6db74>&#34;Sydney&#34;</span>),
</span></span><span style=display:flex><span>    coalescedService.GetWeatherForecast(<span style=color:#e6db74>&#34;Havana&#34;</span>),
</span></span><span style=display:flex><span>    coalescedService.GetWeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>),
</span></span><span style=display:flex><span>    coalescedService.GetWeatherForecast(<span style=color:#e6db74>&#34;London&#34;</span>),
</span></span><span style=display:flex><span>    coalescedService.GetWeatherForecast(<span style=color:#e6db74>&#34;Havana&#34;</span>),
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> coalescedForecast = <span style=color:#66d9ef>await</span> Task.WhenAll(coalescedRequests);
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> f <span style=color:#66d9ef>in</span> coalescedForecast)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(f);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As we run this new implementation, using the <code>CoalescedWeatherForecastService</code>, we get the following output.</p><pre tabindex=0><code>Fetching Weather Forecast for London...
Fetching Weather Forecast for Havana...
Fetching Weather Forecast for Sydney...

WeatherForecast { Location = London, Temperature = 4 }
WeatherForecast { Location = Sydney, Temperature = 32 }
WeatherForecast { Location = Havana, Temperature = 32 }
WeatherForecast { Location = London, Temperature = 4 }
WeatherForecast { Location = London, Temperature = 4 }
WeatherForecast { Location = Havana, Temperature = 32 }
</code></pre><p>As we can see now the actual request to fetch the weather forecast is happening only once per location, and still all six tasks returned a result. No wasteful work ðŸ˜Œ</p><h2 id=final-thoughts>Final thoughts</h2><p>The task-coalescing technique can be good for mitigating issues that arise from cache stampede and in general scenarios when computing expensive results with high concurrency. I&rsquo;m not suggesting we should always use this technique, as its value depends on the specific scenario and the problem this aims to solve may have other preferred mitigating strategies. On the positive side, this technique can be easily implemented without big code refactoring or deploying additional infrastructure. It is one of those techniques that can throw big performance improvements in exchange for little time investment, what some people call quick wins ðŸ˜Š</p><p>Keep dotnetting&mldr;</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 000-6 3 3 0 000 6"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/dotnet/ rel=tag>dotnet</a></li><li class=tags__item><a class="tags__link btn" href=/tags/csharp/ rel=tag>csharp</a></li><li class=tags__item><a class="tags__link btn" href=/tags/concurrency/ rel=tag>concurrency</a></li><li class=tags__item><a class="tags__link btn" href=/tags/task-coalescing/ rel=tag>task-coalescing</a></li><li class=tags__item><a class="tags__link btn" href=/tags/task/ rel=tag>task</a></li><li class=tags__item><a class="tags__link btn" href=/tags/cache-stampede/ rel=tag>cache-stampede</a></li><li class=tags__item><a class="tags__link btn" href=/tags/lazy/ rel=tag>lazy</a></li><li class=tags__item><a class="tags__link btn" href=/tags/concurrentdictionary/ rel=tag>concurrentdictionary</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="Lester Sanchez avatar" src=/img/avatar.jpg class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About Lester Sanchez</span></div><div class=authorbox__description>I am passionate about Computer Science and Cloud Technologies, recently exploring and experimenting with Agentic Engineering. I have worked with different frameworks and languages during the last 20 years, but .NET/C# have been the most beloved pair. I started this blog to share some of my findings, that have been useful to me at some point of my career. I hope they can be useful for you too.</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/2023/05/how-to-do-logging-in-.net-aws-lambda-functions/ rel=prev><span class=pager__subtitle>Â«&#8201;Previous</span><p class=pager__title>How to do logging in .NET AWS Lambda functions</p></a></div></nav><section class=comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//dotnetting.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2026 dotNetting.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>